===== backend/app/worker.py =====
import time
import requests
import socket
import dns.resolver
from urllib.parse import urlparse
from celery import Celery
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
from datetime import datetime
from app.models import Service, HealthCheck
import app.config as config
import ping3

celery = Celery('worker', broker=config.REDIS_URL)
engine = create_engine(config.DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

def perform_check(service):
    start = time.time()

    try:
        if service.check_type == "HTTP":
            return check_http(service.check_target, start)
        elif service.check_type == "PING":
            return check_ping(service.check_target, start)
        elif service.check_type == "TCP":
            return check_tcp(service.check_target, start)
        elif service.check_type == "DNS":
            return check_dns(service.check_target, start)
        elif service.check_type == "SSH":
            return check_ssh_stats(service.check_target, start)
        else:
            return "DOWN", None, "Unsupported check type"
    except Exception as e:
        return "DOWN", None, f"General error: {str(e)}"

def check_http(target, start):
    try:
        resp = requests.get(target, timeout=5)
        response_time = time.time() - start
        if resp.ok:
            return "UP", response_time, None
        else:
            return "DOWN", response_time, f"HTTP Status: {resp.status_code}"
    except Exception as e:
        return "DOWN", None, f"HTTP error: {str(e)}"

def check_ping(target, start):
    try:
        ping3.EXCEPTIONS = True
        latency = ping3.ping(target, timeout=3)
        response_time = time.time() - start
        if latency is not None and latency >= 0.1:
            return "UP", response_time, None
        else:
            return "DOWN", None, "Ping timeout or invalid latency"
    except Exception as e:
        return "DOWN", None, f"Ping error: {str(e)}"

def check_tcp(target, start):
    try:
        host, port = target.split(":")
        port = int(port)
        with socket.create_connection((host, port), timeout=5):
            response_time = time.time() - start
            return "UP", response_time, None
    except Exception as e:
        return "DOWN", None, f"TCP error: {str(e)}"

def check_dns(target, start):
    try:
        dns.resolver.resolve(target, lifetime=5)
        response_time = time.time() - start
        return "UP", response_time, None
    except Exception as e:
        return "DOWN", None, f"DNS error: {str(e)}"

@celery.task
def check_services():
    db = SessionLocal()
    try:
        services = db.query(Service).filter(Service.is_active == True).all()
        health_checks = []
        now = datetime.utcnow()

        for service in services:
            status, response_time, error = perform_check(service)
            health_checks.append(HealthCheck(
                service_id=service.id,
                status=status,
                response_time=response_time,
                error_message=error,
                checked_at=now
            ))
            service.last_checked_at = now

        db.add_all(health_checks)
        db.commit()

    except Exception as e:
        print(f"Worker Error: {e}")
        db.rollback()
    finally:
        db.close()

celery.conf.beat_schedule = {
    "check-every-30-seconds": {
        "task": "app.worker.check_services",
        "schedule": 30.0,
    }
}===== backend/app/auth.py =====
import os
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext

SECRET_KEY = os.getenv("SECRET_KEY", "super-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24

# bcrypt hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta if expires_delta else timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_access_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None===== backend/app/config.py =====
import os
from dotenv import load_dotenv
import secrets

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
dotenv_path = os.path.join(base_dir, '.env')
load_dotenv(dotenv_path=dotenv_path)

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    POSTGRES_USER = os.getenv("POSTGRES_USER", "Admin")
    POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "Password")
    POSTGRES_HOST = os.getenv("POSTGRES_HOST", "localhost")
    POSTGRES_PORT = os.getenv("POSTGRES_PORT", "5432")
    POSTGRES_DB = os.getenv("POSTGRES_DB", "statuspage")
    DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}"

REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379/0")
if not REDIS_URL:
    REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
    REDIS_PORT = os.getenv("REDIS_PORT", "6379")
    REDIS_DB = os.getenv("REDIS_DB", "0")
    REDIS_URL = f"redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}"

SECRET_KEY = os.getenv("SECRET_KEY")
if not SECRET_KEY:
    SECRET_KEY = secrets.token_urlsafe(32)
===== backend/app/models.py =====
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Float, ForeignKey, UniqueConstraint
from sqlalchemy.orm import relationship
from app.database import Base
from datetime import datetime

class Service(Base):
    __tablename__ = "services"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    check_type = Column(String(20), nullable=False)
    check_target = Column(String(255), nullable=False)
    frequency = Column(Integer, nullable=False, default=60)
    is_active = Column(Boolean, default=True)
    last_checked_at = Column(DateTime, nullable=True)

    health_checks = relationship("HealthCheck", back_populates="service")

    __table_args__ = (
        UniqueConstraint('name', 'check_target', name='unique_service_name_target'),
    )

class HealthCheck(Base):
    __tablename__ = "healthchecks"
    id = Column(Integer, primary_key=True, index=True)
    service_id = Column(Integer, ForeignKey("services.id"), nullable=False, index=True)
    status = Column(String(10), nullable=False)
    response_time = Column(Float, nullable=True)
    error_message = Column(String(255), nullable=True)
    checked_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    service = relationship("Service", back_populates="health_checks")

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)===== backend/app/database.py =====
import time
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker
import app.config as config

# Retry logic for database connection
for i in range(10):
    try:
        engine = create_engine(config.DATABASE_URL)
        connection = engine.connect()
        connection.close()
        break
    except Exception as e:
        print(f"Database not ready yet ({i+1}/10): {e}")
        time.sleep(5)
else:
    raise Exception("Database connection failed after multiple attempts.")

SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()===== backend/app/__init__.py =====
===== backend/app/generate_env.py =====
import os
import secrets

POSTGRES_USER = "Admin"
POSTGRES_PASSWORD = "Password"
POSTGRES_DB = "statuspage"
POSTGRES_PORT = "55432"
POSTGRES_HOST = "db"
REDIS_HOST = "redis"
REDIS_PORT = "6379"
REDIS_DB = "0"
SECRET_KEY = secrets.token_urlsafe(32)

DATABASE_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}"
REDIS_URL = f"redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}"

env_path = os.path.join(os.path.dirname(__file__), "..", "..", ".env")

if not os.path.exists(env_path):
    with open(env_path, "w") as f:
        f.write(f"# POSTGRES SYSTEM USER\n")
        f.write(f"POSTGRES_USER={POSTGRES_USER}\n")
        f.write(f"POSTGRES_PASSWORD={POSTGRES_PASSWORD}\n")
        f.write(f"POSTGRES_DB={POSTGRES_DB}\n")
        f.write(f"POSTGRES_HOST={POSTGRES_HOST}\n")
        f.write(f"POSTGRES_PORT={POSTGRES_PORT}\n")
        f.write(f"DATABASE_URL={DATABASE_URL}\n")
        f.write("\n")
        f.write("# REDIS\n")
        f.write(f"REDIS_URL={REDIS_URL}\n")
        f.write(f"REDIS_PORT={REDIS_PORT}\n")
        f.write("\n")
        f.write("# SECRET KEY\n")
        f.write(f"SECRET_KEY={SECRET_KEY}\n")
        f.write(f"RUNNING_IN_DOCKER=true\n")

    print("✅ .env file generated successfully.")
else:
    print("✅ .env file already exists, skipping generation.")===== backend/app/schemas.py =====
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class ServiceBase(BaseModel):
    name: str
    check_type: str
    check_target: str
    frequency: int

class ServiceCreate(ServiceBase):
    pass

class ServiceOut(ServiceBase):
    id: int
    is_active: bool
    last_checked_at: Optional[datetime]

    class Config:
        orm_mode = True

class UserCreate(BaseModel):
    email: str
    password: str

class UserOut(BaseModel):
    id: int
    email: str

    class Config:
        orm_mode = True

class HealthCheckOut(BaseModel):
    id: int
    service_id: int
    status: str
    response_time: Optional[float]
    error_message: Optional[str]
    checked_at: datetime

    class Config:
        orm_mode = True===== backend/app/utils.py =====
from fastapi import HTTPException, status

def raise_not_found(msg="Item not found"):
    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=msg)

def raise_unauthorized(msg="Unauthorized"):
    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=msg)===== backend/app/SSH.py =====
import paramiko
from dotenv import load_dotenv

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
dotenv_path = os.path.join(base_dir, '.env')
load_dotenv(dotenv_path=dotenv_path)

def get_server_stats(host, username, password):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(hostname=host, username=username, password=password)

        commands = {
            "CPU": "top -bn1 | grep 'Cpu(s)'",
            "RAM": "free -m",
            "Disk": "df -h /"
        }

        results = {}
        for key, command in commands.items():
            stdin, stdout, stderr = ssh.exec_command(command)
            output = stdout.read().decode().strip()
            results[key] = output

        ssh.close()
        return results

    except Exception as e:
        return {"error": str(e)}

host = "192.168.1.100"
username = "your_user"
password = "your_password"

stats = get_server_stats(host, username, password)

for section, output in stats.items():
    print(f"--- {section} ---")
    print(output)
    print()
===== backend/app/main.py =====
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session, joinedload
from datetime import datetime, timedelta
from app import models, database, crud, schemas

models.Base.metadata.create_all(bind=database.engine)

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "API is running!"}

def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/services", response_model=schemas.ServiceOut)
def create_service(service: schemas.ServiceCreate, db: Session = Depends(get_db)):
    valid_check_types = ("HTTP", "PING", "TCP", "DNS", "SSH")
    if service.check_type not in valid_check_types:
        raise HTTPException(status_code=400, detail=f"Invalid check type. Valid options: {valid_check_types}")
    return crud.create_service(db, service)

@app.get("/services", response_model=list[schemas.ServiceOut])
def read_services(db: Session = Depends(get_db)):
    return crud.get_services(db)

@app.get("/services/{service_id}/health", response_model=list[schemas.HealthCheckOut])
def read_health(service_id: int, db: Session = Depends(get_db)):
    service = crud.get_service(db, service_id)
    if not service:
        raise HTTPException(status_code=404, detail="Service not found")
    return crud.get_health_checks(db, service_id)

@app.get("/public")
def public_status(db: Session = Depends(get_db)):
    services = db.query(models.Service).options(joinedload(models.Service.health_checks)).all()
    result = []
    now = datetime.utcnow()
    staleness_limit = timedelta(minutes=5)

    for s in services:
        healths = s.health_checks or []
        last_health = max(
            (h for h in healths if h.checked_at is not None),
            key=lambda x: x.checked_at,
            default=None
        ) if healths else None

        if last_health:
            age = now - last_health.checked_at
            if age > staleness_limit:
                status = "Unknown"
            else:
                status = last_health.status
        else:
            status = "Unknown"

        result.append({
            "name": s.name,
            "status": status,
            "last_checked_at": last_health.checked_at.isoformat() if last_health else None,
            "response_time": last_health.response_time if last_health else None,
            "error_message": last_health.error_message if last_health else None
        })

    return result

@app.delete("/services/{service_id}")
def delete_service(service_id: int, db: Session = Depends(get_db)):
    success = crud.delete_service(db, service_id)
    if not success:
        raise HTTPException(status_code=404, detail="Service not found")
    return {"message": "Service deleted successfully"}===== backend/app/crud.py =====
from sqlalchemy.orm import Session
from app import models, schemas, auth, config
from typing import Optional
from app.models import Service, HealthCheck

# Health Checks
def get_health_checks(db: Session, service_id: int):
    return db.query(HealthCheck).filter(HealthCheck.service_id == service_id).order_by(HealthCheck.checked_at.desc()).limit(10).all()

# Users
def create_user(db: Session, user: schemas.UserCreate):
    hashed_password = auth.hash_password(user.password)
    db_user = models.User(email=user.email, hashed_password=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.email == email).first()

def get_user(db: Session, user_id: int) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.id == user_id).first()

# Services
def create_service(db: Session, service: schemas.ServiceCreate):
    db_service = models.Service(**service.dict())
    db.add(db_service)
    db.commit()
    db.refresh(db_service)
    return db_service

def get_services(db: Session):
    return db.query(models.Service).all()

def get_service(db: Session, service_id: int):
    return db.query(models.Service).filter(models.Service.id == service_id).first()

def delete_service(db: Session, service_id: int) -> bool:
    service = db.query(models.Service).filter(models.Service.id == service_id).first()
    if not service:
        return False
    db.delete(service)
    db.commit()
    return True===== frontend/src/App.jsx =====
import React, { useState, useEffect } from 'react';

function App() {
  const [services, setServices] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchServices();
    const interval = setInterval(fetchServices, 30000);
    return () => clearInterval(interval);
  }, []);

  const fetchServices = async () => {
    try {
      const response = await fetch('/api/public');
      if (!response.ok) {
        throw new Error('Failed to fetch services');
      }
      const data = await response.json();
      setServices(data);
      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const getStatusColor = (status) => status ? '#10B981' : '#EF4444';
  const getStatusText = (status) => status ? 'Operational' : 'Down';

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <div>Loading...</div>
      </div>
    );
  }

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <header style={{ textAlign: 'center', marginBottom: '40px' }}>
        <h1>Service Status</h1>
        <p>Current operational status of services</p>
      </header>

      {error && (
        <div style={{ backgroundColor: '#FEE2E2', color: '#DC2626', padding: '12px', borderRadius: '8px', marginBottom: '20px' }}>
          Error: {error}
        </div>
      )}

      <div>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
          <h2>Services</h2>
          <button onClick={fetchServices} style={{ backgroundColor: '#3B82F6', color: 'white', padding: '8px 16px', borderRadius: '6px' }}>
            Refresh
          </button>
        </div>

        {services.length === 0 ? (
          <div style={{ textAlign: 'center', padding: '40px' }}>
            No services configured yet
          </div>
        ) : (
          <div style={{ border: '1px solid #E5E7EB', borderRadius: '8px' }}>
            {services.map((service, index) => (
              <div key={index} style={{ display: 'flex', justifyContent: 'space-between', padding: '16px 20px', borderBottom: index < services.length - 1 ? '1px solid #E5E7EB' : 'none' }}>
                <h3>{service.name}</h3>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <div style={{ width: '12px', height: '12px', borderRadius: '50%', backgroundColor: getStatusColor(service.status) }} />
                  <span style={{ color: getStatusColor(service.status) }}>{getStatusText(service.status)}</span>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      <footer style={{ textAlign: 'center', marginTop: '40px' }}>
        Last updated: {new Date().toLocaleString()}
      </footer>
    </div>
  );
}

export default App;===== frontend/src/index.jsx =====
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
===== backend/Dockerfile =====
FROM python:3.12-slim

RUN apt-get update && apt-get install -y gcc libpq-dev iputils-ping && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app ./app

ENV PYTHONPATH=/app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]===== frontend/Dockerfile =====
FROM node:20-slim AS build

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm install

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]===== docker-compose.yml =====
services:

  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: Admin
      POSTGRES_PASSWORD: Password
      POSTGRES_DB: statuspage
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./initdb:/docker-entrypoint-initdb.d
    ports:
      - "55432:55432"

  redis:
    image: redis:alpine
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  backend:
    build:
      context: ./backend
    environment:
      DATABASE_URL: postgresql://Admin:Password@db:5432/statuspage
      REDIS_URL: redis://redis:6379/0
      SECRET_KEY: super-secret-key
    depends_on:
      - db
      - redis
    ports:
      - "8000:8000"

  worker:
    build:
      context: ./backend
    command: celery -A app.worker worker --loglevel=info
    environment:
      DATABASE_URL: postgresql://Admin:Password@db:5432/statuspage
      REDIS_URL: redis://redis:6379/0
      SECRET_KEY: super-secret-key
    depends_on:
      - backend
      - redis

  scheduler:
    build:
      context: ./backend
    command: celery -A app.worker beat --loglevel=info
    environment:
      DATABASE_URL: postgresql://Admin:Password@db:5432/statuspage
      REDIS_URL: redis://redis:6379/0
      SECRET_KEY: super-secret-key
    depends_on:
      - backend
      - redis

  frontend:
    build:
      context: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data: